---
title: java笔记——继承
tags:
  - java
id: 96
categories:
  - software
date: 2015-01-07 16:22:54
---

通过继承，整个过程可以分为三个层次: 基类定义，衍生类定义，外部使用。

&nbsp;

基类定义的层次就是正常的定义一个类。

&nbsp;

在外部使用者看来，衍生类有一个统一的外部接口:

&nbsp;

对于外部使用者来说，上述接口就已经足够了。仅从接口看，衍生类也没有什么特别之处。

&nbsp;

&nbsp;

然而，我们在衍生类定义的层次时，就要注意:

&nbsp;

首先，接口是混合的: 一些来自基类，另一些方法则是在衍生类内部定义的。

&nbsp;

还有更加复杂的地方。我们之前在类的内部可以自由访问类的成员(利用this指代对象)。然而，当我们在

Woman类的定义范围内，我们无法访问基类Human的private成员。我们记得private的含义: private的成员仅

供该类内部使用。Woman类是一个不同于Human类的新类，所以位于Human类的外部。在衍生类中，不能不能访

问基类的private成员。

&nbsp;

&nbsp;

为了清晰概念，我们需要了解衍生类对象的生成机制。当我们创建一个衍生类的对象时，Java实际上先创建

了一个基类对象(subobject)，并在基类对象的外部(注意，这里是基类对象的外部，衍生类对象的内部)，增

加衍生类定义的其他成员，构成一个衍生类对象。外部使用者能看到的，就是基类和衍生类的public成员。

&nbsp;

super和this类似，也是隐式参数。我们在类定义的不同层次时，this会有不同的含义。要小心的使用this和

super关键字。(Java并不强制使用this和super，Java在许多情况下可以自动识别成员的归属）

&nbsp;

&nbsp;

Java是同时通过方法名和参数列表来判断所要调用的方法的。方法是由方法名和参数列表共同决定的。上述

问题中，如果只是方法名相同，而参数列表不同，那么两个方法会同时呈现到接口，不会给我们造成困扰。

外部调用时，Java会根据提供的参数，来决定使用哪个方法 (方法重载)。

&nbsp;

如果方法名和参数列表都相同呢？ 在衍生层时，我们还可以通过super和this来确定是哪一个方法。而在外

部时，我们呈现的只是统一接口，所以无法同时提供两个方法。这种情况下，Java会呈现衍生层的方法，而

不是基层的方法。

&nbsp;

这种机制叫做方法覆盖(method overriding)。

标为protected的成员在该类及其衍生类中可见。这个概念很容易理解，就是说，基类的protected成员可以

被衍生层访问，但不能被外部访问。

&nbsp;

位于衍生层，依然可以通过super来调用基类对象的breath()方法。当我们外部调用Woman类时，由于方法覆盖，就无法再调用基类对象的该方法了。

&nbsp;

由于在创建衍生对象的时候，基类对象先被创建和初始化，所以，基类的构造方法应该先被调用。我们可以

使用super(argument list)的语句，来调用基类的构造方法。
